from __future__ import annotations

from dataclasses import asdict, astuple, dataclass
from json import dumps
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Any


@dataclass(frozen=True)
class Message:
    """
    The `Message` dataclass serves as a base class for message types
    that can be defined in the message.py file. Other message classes
    inherit from `Message`.

    Messages represent protocol-layer payloads and are not interpreted
    by the medium.
    """

    pass


@dataclass(frozen=True)
class FloodBeaconMessage(Message):
    """
    Payload for a Glossy flood beacon.

    Attributes:
        FLOOD_ID (str):
            Unique identifier for a flood instance. This value is
            generated by the sink and must not be modified by
            intermediate nodes.
    """

    FLOOD_ID: str


@dataclass(frozen=True)
class Frame:
    """
    Represents a complete transmission-ready frame, including header
    information and the payload data.

    Intermediate nodes must not modify frame contents.

    The payload should be an instance of the `Message` dataclass
    (or a subclass).
    """

    TYPE: str
    SRC: int
    DST: int
    SEQ: int
    PAYLOAD: Message

    @property
    def identity(self) -> tuple[Any, ...]:
        """
        Canonical identity of the frame.

        Two frames with the same identity are considered identical
        on the air and may constructively interfere.

        This identity must be stable, hashable, and independent of
        serialization or logging format.
        """
        return astuple(self)


def frame_to_json(frame: Frame, sort_keys: bool = False) -> str:
    """
    Converts a `Frame` dataclass instance into a JSON-formatted string.
    This function is intended for debugging and logging only.
    It does not model actual PHY-layer encoding.

    """
    return dumps(asdict(frame), sort_keys=sort_keys)
